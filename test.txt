* Guava
http://blog.outsider.ne.kr/710

* Test annotaion 코드 규칙3가지 

* 작성코드를 그림으로 표현해보기 

* Collection Framework  
http://withwani.tistory.com/150

 . List V, L.L, A.L
 . Map  H.T, H.M, S.H.M - T.M
 . Set  H.S, S.H.S      - T.S
 . sync를 보장 
 
* Linked List : node=vertax=element : add

* Mybatis : Sqlsession : SqlSessionFactory : SqlSessionFactory.builder
   http://www.mybatis.org/spring/ko/sqlsession.html

* Lombok : 
  Slf4j, annotation : data, getter, setter, AllArgsConstructor, NoArgsConstructor, ToString 

* Java8 
  Funtional interface 
  Consumer<T>, Function<T,R>, Predicate<T>, Supplier<T> : Lazy evaluation 

* Bean Scope : singleton, request, session, prototype

* String, Stringbuffer, Stringbuiller
  immutable, mmutable  
           Thread Safe

mutable과 immutable pattern
우선 이 두 개념을 간단하게 보자. 공유 자원들은 사용시 thread safety(multi-thread safety)해야 올바른 결과를 보장할 수 있다. 그래서 immutable은 한번 만든 객체는 변경되지 않으며, 변경시에는 새로운 객체를 만든다. 이 말은 synchronized하지 않아도 thread safety하다는 뜻이다. mutable은 원본 자체를 수정해야하기 때문에 synchronized해야만 올바른 결과가 보장된다.
 
String Class
 이 녀석은 immutable한 클래스이다. 변경 불가능한 클래스라는 뜻이다. 하지만 안의 메소드(toLowerCase(), trim()... 등등)를 생각해보면 자칫 변경가능한 녀석이라고 생각할 수 있다. 하지만 실제론 안에서 원본 객체는 놔둔채 각메서드에서 새로운 객체를 만들어 기능을 처리한 후 반환한다. 즉, 원본은 변경되지 않는 것이다. 그래서 String 클래스는 객체를 새로 할당하는 시간 및 새로운 메모리사용 때문에 다른 문자열 클래스에 비해 좀 더 느리다고 생각될 수 있다.
 
StringBuffer Class
 이 녀석은 mutable하다. 그러니까 가지고 있는 원본을 수정할 수 있도록 만든 Class이다. 당연 thread safety하기 위한 synchronized과정이 있다. 이 synchronized과정에 있어서 단순한 참조를 할경우 String보다 bad performance를 보인다.
 
StringBuilder Class
 이 녀석 또한 mutable하다. StringBuffer와 동일한 기능을 갖고있는데 차이점이라고 한다면 thread safety하지 않다. 즉, synchronized 과정이 없다는 것 이다. 그래서 thread safety할 필요 없는 코드라면 stringBuffer가 아닌 StringBuilder를 써야 더 좋은 performance가 나온다.

             
* IO inputstream berfferedstream fileinputstream  : IO : 데코레이션패턴
      타깃에 부가적인 기능을 런타임 시 다이나믹하게 부여해주기 위해서 프록시를 사용하는 패턴 데코레이터 패턴

* Spring AOP
  JDK 다아나믹 프록시 --> FactoryBean implement --> proxyFactoryBean 
  advisor = advice(부가기능), pointcut(메서드 선정 알고리즘), MethodInvocation

   DefaultAdvisorAutoProxyCreator 클래스빈등록 ID없다.빈의 후처리기로 참여  
 
   pointcut 표현식을 위해서 필요한 class AspectJExpressionPointcut

AspectJ 표현식 샘플 
"execution(* *..TargetInterface.*(..))"
"execution(* *..Tar*.*(..))"
"execution(* *(..) throws Runtime*)"
AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
		pointcut.setExpression(expression);
		
		assertThat(pointcut.getClassFilter().matches(clazz) &&
				   pointcut.getMethodMatcher().matches(
						   clazz.getMethod(methodName, args), null), 
				   is(expected));

spring
bean(*Service)	
@annotation(org .springframework .transaction .annotation.Transactional)			   


DefaultTransactionDefinition Class 
- Transaction PROPAGATION (REQUIRED, REQUIRES_NEW, NOT SUPPORTED)
- isolation level (ISOLATION_DEFAULT
- timeout
- read only

Transactionlnterceptor 
TransactionAttribute를 Properties
  PROPAGATION_NAME, ISOLATION_NAME, readOnly , timeout_NNNN, -Exceptionl , +Exception2

@Transactional 어노테이션의 대체 fallback 정책
(1)
public interface Service{
	(2)
	void method1();
	(3)
	void method2();
}

(4)
public class ServiceImpl implements Service{
	(5)
	public void method1(){...}
	(6)
	public void method2(){...}
}

* Exception의 두가지형태 
  checked / unchecked Exception 
  checked exception은 컴파일러가 체크하는 익셉션이고,
  unchecked exception은 컴파일러가 체크하지 않는 익셉션입니다. 

다시 말해서 checked exception은 try 문으로 처리하거나 메서드 선언에 throws 절을 써야 컴파일 에러가 발생하지 않고,
unchecked exception은 그렇게 하지 않아도 컴파일 에러가 발생하지 않습니다.
http://cfile28.uf.tistory.com/image/217C6B4552AF12B432A3FF

* OOM 대처방안 혹은 처리했던 경험
* JVM 설명

* GC설명 

* stream 
  ㄴ intermediate operation 
  ㄴ terminal operation 

* algorithms
Asymptotic notation
Recursive algorithms

Binary search
 오름차순으로 정렬된 리스트에서 특정한 값의 위치를 찾는 알고리즘이다. 
처음 중간의 값을 임의의 값으로 선택하여, 그 값과 찾고자 하는 값의 크고 작음을 비교하는 방식을 채택하고 있다. 
처음 선택한 중앙값이 만약 찾는 값보다 크면 그 값은 새로운 최고값이 되며, 작으면 그 값은 새로운 최하값이 된다. 
검색 원리상 정렬된 리스트에만 사용할 수 있다는 단점이 있지만, 
검색이 반복될 때마다 목표값을 찾을 확률은 두 배가 되므로 속도가 빠르다는 장점이 있다. 
이진 검색은 분할 정복 알고리즘의 한 예이다.

Selection sort
Insertion sort
Merge sort
Quick sort

* singleton 코드
public TestClass {
	/*유일한 인스턴스 저장 객체 선언*/
	private static TestClass _instance ;
	private TestClass(){ }

	/*외부에서 사용할 함수 선언 클래스를 생성할떄 쓴다 */
	public static Singleton getInstanceDC() { 
		if (_instance == null) { // Single Checked 
			synchronized (Singleton.class) { 
				if (_instance == null) { // Double checked 
					_instance = new Singleton(); 
				} 
			} 
		} return _instance; 
	}
}

* DB Test
